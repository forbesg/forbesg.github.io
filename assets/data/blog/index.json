{"hash":"402bbf5bc9d4e8238c96b787c17a72a6b99f3750","data":{"articles":{"edges":[{"node":{"id":"9b742d2188e2f60e7a272bd95c423035","title":"A Static Ecommerce Website with Shopify","description":"Shopify has become one of the go-to ecommerce platforms. We can create a simple fast online shopping experience hooking in to the Shopify Storefront API.","path":"/blog/a-static-ecommerce-website-with-shopify/","image":"/images/articles/shopify-graphql-jamstack.jpg.png","imageAlt":"Shopify Storefront API, GraphQL, Static Ecommerce Website","content":"<h2 id=\"the-storefront-api\"><a href=\"#the-storefront-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>The Storefront API</h2>\n<p>When looking into possible ecommerce frameworks, it is hard not to stumble across Shopify. Over the past 5 to 10 years it has become a bit of a monster when it comes to the online shopping space. What has also been encoraging is that they have continued to innovate and lead the way in terms of development, and were quick to move with the times as the JAMstack trend took hold.</p>\n<p>The Storefront API allows access to the ecommerce store &#x26; product data via a GraphQL API which allows you to request precisely the information that you require to construct the page, keeping everything as lightweight as possible. In addition to this it handles customer authentication.</p>\n<h3 id=\"what-well-build\"><a href=\"#what-well-build\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>What we'll build</h3>\n<p>I wanted to test <a href=\"https://shopify.dev/api/storefront\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Shopify's Storefront API</a>, so came up with a simple ecommerce grocery store idea to test the API.</p>\n<p>The beauty of this architecture is that you are able to access your store data through multiple channels (websites, apps, POS devices) whilst retaining the ability to manage your stores backend using Shopify's familiar and well-tested platform.</p>\n<p><img src=\"/images/articles/farm-foods-store.jpg\" alt=\"Farm Foods Store Screenshot\"></p>\n<h3 id=\"the-frontend\"><a href=\"#the-frontend\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>The Frontend</h3>\n<p>For the frontend (website) I chose to use NuxtJS, however a similar approach could be taken with anu modern frontend web framework. With Nuxt I am able to choose whether to make the website a static site (pre-built and server as static pages) or server rendered (pages are constructed on every request). For this example I will be choosing to create a static build of the site which means it can be hosted for free and will be very fast.</p>\n<p>I styled the site a little using Tailwind css but we will not be going into the detail of that here. Tailwind was good for quickly creating a responsive website that doesn't look totally awful.</p>\n<p>The first step was to install a fresh version of NuxtJS and including tailwind.</p>\n<pre><code class=\"language-bash\">npx create-nuxt-app farm-foods-store\n\ncd farm-foods-store\nnpm install\n</code></pre>\n<p>With Nuxt installed we then need to add the node shopify api library to enable us to easily interact with the Storefront API.</p>\n<pre><code class=\"language-bash\">npm install @shopify/shopify-api\n</code></pre>\n<h3 id=\"setting-up-the-shopify-store\"><a href=\"#setting-up-the-shopify-store\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Setting Up The Shopify Store</h3>\n<p>First we need to create a Shopify Store to work with. Sign up or login to <a href=\"https://shopify.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Shopify</a> and create a new development store. Follow the setup guide to give the store a name, location and contact details and prompted to add some products.</p>\n<p>Once the store is created and we have some products to work with, we need to create a Private App to enable us to interact with the API securely. Enter your newly created store admin site and open the settings menu and select Apps and sales channels -> App development and Create an App.</p>\n<p>We give the new private app a name (e.g Storefront API) and scroll down to the Storefront API section. Check the box to allow the app to access storefront data and ensure that all subsequent permissions are checked. At the bottom of this section we can find the Storefront Access Token that we need to allow our website to access the API.</p>\n<h3 id=\"hook-up-our-website-to-the-api\"><a href=\"#hook-up-our-website-to-the-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Hook Up Our Website To The API</h3>\n<p>Now we have an access token for the Storefront API we need to give Nuxt the credentials needed to communicate with our stores backend. In the root of our Nuxt project create a .env file and include the following....</p>\n<pre><code class=\"language-bash\" class=\"env\">// .env\n\nNUXT_STORE_URL=https://&#x3C;the-store-name>.myshopify.com\nNUXT_STORE_API_ENDPOINT=https://&#x3C;the-store-name>.myshopify.com/api/2021-10/graphql.json\nNUXT_STORE_ACCESS_TOKEN=&#x3C;access token created in the previous step>\n</code></pre>\n<p>Nuxt automatically pulls in the environment variables from the .env file but we do need to make them accessible by the frontend of the site. This is easliy achieved using Nuxt's publicRuntimeConfig, values that can be access from the client side of the website. In the nuxt.config.js we can add the enviorment variables to the publicRuntimeConfig.</p>\n<pre><code class=\"language-javascript\">// nuxt.config.js\n\nconst storeUrl = process.env.NUXT_STORE_URL;\nconst storeAPIEndpoint = process.env.NUXT_STORE_API_ENDPOINT;\nconst storeAccessToken = process.env.NUXT_STORE_ACCESS_TOKEN;\n\nexport default {\n  ...\n  publicRuntimeConfig: {\n    storeUrl,\n    storeAPIEndpoint,\n    storeAccessToken,\n  },\n  ...\n};\n</code></pre>\n<h3 id=\"the-last-piece-of-the-jigsaw\"><a href=\"#the-last-piece-of-the-jigsaw\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>The Last Piece of the Jigsaw</h3>\n<h4 id=\"connecting-to-the-shopify-api\"><a href=\"#connecting-to-the-shopify-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Connecting to the Shopify API</h4>\n<p>We have one final thing to do to enable requests to be made to the Shopify GraphQL API. We have installed the Shopify API library but we still need to give the site access to it and instantiate a client with the store API credentials.</p>\n<p>What we will do is create a <a href=\"https://nuxtjs.org/docs/directory-structure/plugins\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Nuxt plugin</a> to instatiate the client and then inject it into the Vue instance so we can call the API from anywhere within our application. Thanks to the Nuxt publicRuntimeConfig, we can access all the environment variables that we previously set up using the <code>$config</code> property passed to the plugin.</p>\n<pre><code class=\"language-javascript\">// ~/plugins/shopify.js\n\nexport default ({ app: { $config } }, inject) => {\n  const client = function(query, variables) {\n    return fetch($config.storeAPIEndpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-Shopify-Storefront-Access-Token\": $config.storeAccessToken,\n      },\n      body: JSON.stringify({ query, variables: variables || null }),\n    });\n  };\n  inject(\"client\", client);\n};\n</code></pre>\n<p>As you can see we are setting up the client request with the necessary headers and passing in the GraphQL query and variables. Finally we inject the client function into the application context making it accessible using the app contexts <code>$client</code> property.</p>\n<p>Finally, let's make a request to the API from the products page asyncData method.</p>\n<pre><code class=\"language-javascript\">// ~/pages/products.vue\nexport default {\n  async asyncData({ $client }) {\n    const query = `\n      {\n        products (first: 3) {\n          edges {\n            node {\n              title\n              productType\n              description\n            }\n          }\n        }\n      }\n    `;\n\n    const {\n      data: { products },\n    } = await $client(query).then((res) => res.json());\n\n    /**  Shopify Storefront API Response\n      {\n        \"data\": {\n          \"products\": {\n            \"edges\": [\n              {\n                \"node\": {\n                  \"title\": \"Carrots\",\n                  \"productType\": \"Fresh &#x26; Frozen Vegetables\",\n                  \"description\": \"Fresh Carrots. Very Orange\"\n                }\n              },\n              {\n                \"node\": {\n                  \"title\": \"Broccoli\",\n                  \"productType\": \"Fresh &#x26; Frozen Vegetables\",\n                  \"description\": \"Fresh Broccoli. Very Green\"\n                }\n              },\n              {\n                \"node\": {\n                  \"title\": \"Cauliflower\",\n                  \"productType\": \"Fresh &#x26; Frozen Vegetables\",\n                  \"description\": \"Fresh Cauliflower. Very Tasty\"\n                }\n              }\n            ]\n          }\n        }\n      },\n    **/\n\n    return { products };\n  },\n};\n</code></pre>\n<p>The asyncData method will only be called during the build process of our static site and will make all the data returned in the response available to the page component and we can create and style the page however we would like.</p>\n<p>This approach of consuming Shopify ecommerce data really gives you limitless options when it comes to your UI and customer journey as well as providing customers with a fast and secure online shopping experience.</p>\n<p>View the half finished test <a href=\"https://farm-foods-store.netlify.app/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Farm Foods Store website</a></p>\n<p>If you would like to discuss your e-commerce project please do <a href=\"/contact/\">get in touch</a>.</p>\n","tags":[{"title":"Static Sites","path":"/blog/tags/static-sites/"},{"title":"Ecommerce Websites","path":"/blog/tags/ecommerce-sites/"}]}},{"node":{"id":"3313e10bfde3713edc3ce202f6fe094e","title":"Can An Ecommerce Site Be Static?","description":"Getting an e-commerce website up and running traditionally required a monolithic e-commerce framework, but there are other options available.","path":"/blog/can-an-ecommerce-site-be-static/","image":"/images/articles/ecommerce-payment.jpg","imageAlt":"Static Website Online Shop","content":"<h2 id=\"ecommerce-options-available\"><a href=\"#ecommerce-options-available\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Ecommerce Options Available</h2>\n<p>Traditionally e-commerce websites have been created using well-established frameworks\nlike Shopify, Magento &#x26; WooCommerce. More recently these have been joined by the likes of\nBigCommerce, Squarespace &#x26; Wix, all of which provide a quick and easy way of starting\nto sell online.</p>\n<p>What all of the aforementioned e-commerce platforms have in common is that they are\ntightly coupled with the storefront that the customer sees. Both website and admin\nbackend are running together on the same server and it is that server which creates\nthe e-commerce website. In addition to this, there are limitations in terms of\ndeveloping the site exactly as you want it. The design of the site is constrained\nby the platform itself, and the more flexible a platform is in the design options,\nthe more expensive it becomes to develop.</p>\n<h2 id=\"headless-ecommerce\"><a href=\"#headless-ecommerce\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Headless Ecommerce</h2>\n<p>A more recent addition to the e-commerce space has been the headless e-commerce\nframework. Headless simply refers to the fact that the framework itself doesn't\nhave a storefront, it simply implements the e-commerce backend functionality whilst\nleaving you free to create, design and customise your online shop using any\ntechnology you like. The website (or App...or both) then makes API calls to the e-commerce backend\nto display to the user and facilitate the sales.</p>\n<p>The headless e-commerce space has become very busy very quickly with frameworks\nlike Elasticpath, Vendure and Open Source Sylius whilst the likes of Magento, BigCommerce\nand Shopify have created Headless versions of their frameworks.</p>\n<h3 id=\"omnichannel-sales\"><a href=\"#omnichannel-sales\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Omnichannel Sales</h3>\n<p>Using a headless e-commerce architecture opens up a wide variety of additional\nsales channels and routes to market. A headless e-commerce solution can not only\nallow sales through a website but also provides e-commerce functionality to\nMobile Apps, IoT devices and in-person Point of Sale devices.</p>\n<h3 id=\"design-flexibility\"><a href=\"#design-flexibility\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Design Flexibility</h3>\n<p>With this level of decoupling of the front and backend of an e-commerce framework,\nyou achieve total freedom to create a unique and fast shopping experience for the user and\na faster time to market. It also allows you to easily change your storefront website\nin the future, whether that be design or underlying technology, without touching\nany of the e-commerce backend code.</p>\n<p>Many large multi-national businesses' have embraced this new architecture\nto improve their customer's shopping experience, including Nike, Under Armour,\nTarget &#x26; Debenhams.</p>\n<h2 id=\"taking-headless-ecommerce-static\"><a href=\"#taking-headless-ecommerce-static\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Taking Headless Ecommerce Static</h2>\n<p>Due to the nature of modern static site generators and website build tools,\nheadless e-commerce can fit perfectly into this architecture. Communication is\nmade to the headless API during the build process and creates a static website\nthat can be hosted on any server at a minimal cost.</p>\n<p>Realtime interactions with the backend, such as authentication, inventory\nqueries and sales, can be handled using API requests whilst the user interacts\nwith the site.</p>\n<p>For those on an ultra-low budget, products like Snipcart enable e-commerce functionality\nto be added to any static website with little more than adding a snippet of code to\nthe site.</p>\n<h3 id=\"conclusion\"><a href=\"#conclusion\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Conclusion</h3>\n<p>There are many e-commerce solutions available and the ideal solution will depend on a business' requirements\nand budget.</p>\n<p>We continue to promote a headless approach to <a href=\"/services/ecommerce-website-design/\">developing e-commerce websites</a> and\nwould welcome a no-obligation chat about what solution would be the best fit.</p>\n<p>If you would like to discuss your e-commerce project please do <a href=\"/contact/\">get in touch</a>.</p>\n","tags":[{"title":"Static Sites","path":"/blog/tags/static-sites/"},{"title":"Ecommerce Websites","path":"/blog/tags/ecommerce-sites/"}]}},{"node":{"id":"657c0722bc81d6194d9a96160feb019c","title":"Why Choose A JAMStack Website?","description":"We look at how JAMStack websites differ from more traditional CMS based technologies like Drupal, Joomla and WordPress Websites","path":"/blog/why-choose-a-jam-stack-website/","image":"/images/articles/html-development.jpg","imageAlt":"Static Website written in HTML","content":"<h2 id=\"the-initial-state-of-the-web\"><a href=\"#the-initial-state-of-the-web\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>The Initial State of the Web</h2>\n<p>Before the rise in popularity of content management systems like WordPress, Drupal and Joomla, most sites on the web were simple static pages of HTML markup and CSS. Over a slow connection, these text documents could be served and rendered in the browser relatively quickly.</p>\n<p>As network speeds and browser technology improved, the size of the web grew, as did the size of websites. With larger-scale sites, maintenance and updates of the websites became increasingly more challenging. Server-side code and content management systems came to the rescue by dynamically generating HTML pages on the server, using languages like PHP and frameworks like ASP.NET, before serving them to the browser.</p>\n<h3 id=\"the-content-management-system\"><a href=\"#the-content-management-system\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>The Content Management System</h3>\n<p>The principle behind a content management system is quite straightforward. A request is made by the browser to view a page and the server uses the request to access the database and retrieve the information required to construct the requested page. The server-side code then uses this data to generate an HTML page which is then returned to the browser.</p>\n<p>Working in this way meant that content creators and managers were able to create and update content in a user-friendly interface without having any coding knowledge.</p>\n<p>Adding a new page or blog article was as simple as editing and saving a word document, and CMS' became the go-to technology for building a new website.</p>\n<h3 id=\"so-why-do-we-need-static-sites\"><a href=\"#so-why-do-we-need-static-sites\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>So Why Do We Need Static Sites?</h3>\n<p>As a site grows in size and complexity, the resources required to run it grow too. A server running a content management system is having to work hard every time it receives a request. This means that it needs time to complete these computations, delaying the load time of a page, and also incurs additional hosting costs to be able to run effectively.</p>\n<p>Returning to a static site model of simply serving pre-built HTML pages not only increases the speed that your page is returned, and displayed, to the user but also requires fewer resources from the server as it is not doing any computations when a page is requested, it simply returns a file.</p>\n<h3 id=\"static-site-generators-and-the-jamstack\"><a href=\"#static-site-generators-and-the-jamstack\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Static Site Generators and The JAMStack</h3>\n<p>Static Site Generators started gaining traction in the mid to late 2010s and have exploded in popularity since then. With the release of more API driven resources, the JAMStack was born allowing Static Sites to become a very real alternative to a traditional CMS.</p>\n<h4 id=\"so-a-static-site-is-fast-and-cheap-but-what-about-creating-and-updating-content\"><a href=\"#so-a-static-site-is-fast-and-cheap-but-what-about-creating-and-updating-content\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>So a static site is fast and cheap, but what about creating and updating content?</h4>\n<p>The headless CMS solved this particular problem by decoupling the content itself from the front-end display layer. A CMS needs to store data somewhere, but rather than have the database and the website running in the same environment, the site could simply make requests to a headless CMS at build time and generate the pages which could be served as static files when needed.</p>\n<p>This presented much more flexibility, as the data could be used by a website, mobile app or any connected device able to make an API request. This flexibility has resulted in many of the traditional CMS' offering headless options.</p>\n<h3 id=\"updating-your-static-website\"><a href=\"#updating-your-static-website\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Updating Your Static Website</h3>\n<p>A headless CMS gives the user a familiar interface to create, add and update new content. Someone coming from a traditional CMS would feel very at home working with a headless CMS.</p>\n<p>When new content has been added to the CMS, a static site needs to be rebuilt to show any updated content. The beauty of this is that the build only needs to happen once to update the static files on the hosting server and then all future requests will get the latest static file for that particular page/request.</p>\n<p>This is the reason that the hosting costs of a static website are a fraction of a content management system and in many cases completely free.</p>\n<p>There are many different ways to accomplish this kind of architecture and many awesome products that slot seamlessly into it.</p>\n<h3 id=\"other-benefits-of-a-static-website\"><a href=\"#other-benefits-of-a-static-website\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Other Benefits Of A Static Website</h3>\n<p>There are many reasons to consider a static site for your next project. I have already mentioned the speed and reduced hosting costs, but that's not the end of the list.</p>\n<h4 id=\"security\"><a href=\"#security\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Security</h4>\n<p>I feel that this is one of the main benefits of a static site. Traditional CMS' interact directly with a database on every request, and if you're storing any kind of sensitive data you'll need to make sure that it is secure. We all hear of data breaches of some of the worlds largest sites, but popular CMS' are also a common target for hackers looking for a \"way in\".</p>\n<p>A static site contains only text files and, once created, do not have to interact with or even have access to a database, so in a sense, there's nothing to hack.</p>\n<p>Another common source of CMS attacks is through third-party plug-ins, often used to add functionality to a site. You have little knowledge of the code that the plug-in contains and vulnerabilities, intentional or not, are often discovered putting all the sites that use them at risk.</p>\n<h4 id=\"flexibility\"><a href=\"#flexibility\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Flexibility</h4>\n<p>I have talked a lot about using a headless CMS, but that is not the only way. As a static site generator builds a website it doesn't care where the data itself is coming from. It could be a CMS, but it could also simply be text files, markdown or even a Google Sheet.</p>\n<p>The decoupled nature of the JAMStack also means that you have total freedom of the tools used to create the site. If you wished to change this in the future you do not have to migrate the database, you simply create a new static site to consume the data that you already have. This is perfect for creating something truly unique now and making future changes to ensure that you can stay on-brand.e that the plug-in contains and vulnerabilities, intentional or not, are often discovered putting all the sites that use them at risk.</p>\n<h3 id=\"conclusion\"><a href=\"#conclusion\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Conclusion</h3>\n<p>The choice is up to you. Whether you are considering updating an existing website or starting from scratch with a new project, certainly give a Static JAMStack website a closer look.</p>\n<p>If you would like to discuss any projects that may be able to take advantage of a static site please do <a href=\"/contact/\">get in touch</a>.</p>\n","tags":[{"title":"JAMStack","path":"/blog/tags/jam-stack/"},{"title":"Static Sites","path":"/blog/tags/static-sites/"}]}}]}},"context":{}}